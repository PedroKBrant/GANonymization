<!DOCTYPE html>
<html lang="en">
<head>
    <title>GANonymization</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.1/themes/base/jquery-ui.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet"/>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css">

    <link href="./css/main.css" rel="stylesheet"/>
    <link href="./css/toggle.css" rel="stylesheet"/>
    <link href="./css/sidebar.css" rel="stylesheet"/>

    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
    <script type="text/javascript"
            src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/ui/1.13.1/jquery-ui.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script type="text/javascript"
            src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.min.js"></script>
    <script type="text/javascript"
            src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script type="text/javascript" src="./javascript/webcam-easy.js"></script>

    <script type="module">
        const image_size = 512;
        var status = document.getElementById("status");
        var video = document.getElementById("webcam");
        var canvasLandmarks = document.getElementById("canvas-landmarks");
        canvasLandmarks.setAttribute('willReadFrequently', true);
        var ctxLandmarks = canvasLandmarks.getContext('2d');
        var canvasAnonymized = document.getElementById("canvas-anonymized");
        var ctxAnonymized = canvasAnonymized.getContext('2d');

        // Setup canvas dimensions
        canvasLandmarks.width = window.innerWidth;
        canvasLandmarks.height = window.innerHeight;
        canvasAnonymized.width = window.innerWidth;
        canvasAnonymized.height = window.innerHeight;

        // Clear canvases
        clearCanvas(ctxLandmarks);
        clearCanvas(ctxAnonymized);

        // Type Button event listener
        status.addEventListener('change', function () {
            let dNone = "d-none";
            if (status.checked) {
                canvasLandmarks.classList.add(dNone);
                canvasAnonymized.classList.remove(dNone);
            } else {
                canvasAnonymized.classList.add(dNone);
                canvasLandmarks.classList.remove(dNone);
            }
        });

        // Get FaceMesh landmarks
        const config = {
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@${VERSION}/${file}`;
            }
        };
        const solutionOptions = {
            selfieMode: true,
            enableFaceGeometry: false,
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        };
        const faceMesh = new FaceMesh(config);
        faceMesh.setOptions(solutionOptions);
        faceMesh.onResults(handleFaceMeshResults);

        // Waiting text
        const text = "Please wait a moment.";
        ctxLandmarks.textAlign = 'center';
        ctxLandmarks.fillStyle = 'white';
        ctxLandmarks.font = "20px Arial";
        ctxLandmarks.fillText(text, canvasLandmarks.width / 2, canvasLandmarks.height / 2);

        // Setup Webcam
        (async () => {
            const webcam_model = new Webcam(video, 'environment', canvasLandmarks);
            try {
                const inputDeviceInfos = await webcam_model.info();
                const dropdownMenu = document.getElementById("dropdown-menu");
                let items = "";
                for (let i = 0; i < inputDeviceInfos.length; i++) {
                    const deviceInfo = inputDeviceInfos[i];
                    items += `<button id="button-${i}" class="dropdown-item">${deviceInfo.label}</button>`;
                }
                dropdownMenu.innerHTML = items;
                for (let i = 0; i < inputDeviceInfos.length; i++) {
                    const deviceInfo = inputDeviceInfos[i];
                    const button = document.getElementById(`button-${i}`);
                    button.addEventListener('click', async () => {
                        try {
                            await webcam_model.start(true, deviceInfo.deviceId);
                        } catch (err) {
                            console.log(err);
                        }
                    });
                }
                await webcam_model.start();
                video.requestVideoFrameCallback(predictWebcam);
            } catch (err) {
                console.log(err);
            }
        })();

        async function handleFaceMeshResults(results) {
            if (results.multiFaceLandmarks.length > 0) {
                if (!status.checked) {
                    clearCanvas(ctxLandmarks);
                    ctxLandmarks.save();
                    let x_min = 1;
                    let x_max = 0;
                    let y_min = 1;
                    let y_max = 0;
                    for (const landmark of results.multiFaceLandmarks[0]) {
                        if (landmark.x > x_max) {
                            x_max = landmark.x;
                        } else if (landmark.x < x_min) {
                            x_min = landmark.x;
                        }
                        if (landmark.y > y_max) {
                            y_max = landmark.y;
                        } else if (landmark.y < y_min) {
                            y_min = landmark.y;
                        }
                    }
                    const aspect_ratio = (y_max - y_min) / (x_max - x_min);
                    const face_height = image_size;
                    const face_width = image_size / aspect_ratio;
                    for (const landmark of results.multiFaceLandmarks[0]) {
                        const x_normalized = (landmark.x - x_min) / (x_max - x_min);
                        const y_normalized = (landmark.y - y_min) / (y_max - y_min);
                        const x_center = canvasLandmarks.width / 2;
                        const y_center = canvasLandmarks.height / 2;
                        const x = x_normalized * face_width + x_center - face_width / 2;
                        const y = y_normalized * face_height + y_center - face_height / 2;
                        const circle = new Path2D();
                        circle.arc(x, y, 1, 0, 2 * Math.PI);
                        ctxLandmarks.fillStyle = 'white';
                        ctxLandmarks.fill(circle);
                    }
                    ctxLandmarks.restore();
                } else {
                    try {
                        const response = await fetch('http://137.250.171.85:6060/ganonymization/api/v1.0/landmarks_to_face', {
                            method: 'POST',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({"landmarks": [results.multiFaceLandmarks[0]]})
                        });
                        const output = await response.json();
                        const image = new Image();
                        image.onload = function () {
                            clearCanvas(ctxAnonymized);
                            ctxAnonymized.save();
                            ctxAnonymized.drawImage(image, canvasAnonymized.width / 2 - image.width / 2, canvasAnonymized.height / 2 - image.height / 2, image.width, image.height);
                            ctxAnonymized.restore();
                        };
                        image.src = 'data:image/png;base64,' + output['images'][0];
                    } catch (error) {
                        console.log(error);
                    }
                }
            }
        }

        async function predictWebcam() {
            ctxLandmarks.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, canvasLandmarks.width, canvasLandmarks.height);
            const image = new Image();
            image.src = canvasLandmarks.toDataURL();
            await faceMesh.send({image});
            requestAnimationFrame(predictWebcam);
        }

        function clearCanvas(ctx) {
            const canvas = ctx.canvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'black';
            ctx.fill();
        }
    </script>
</head>
<body>
<main>
    <!-- Sidebar-Left -->
    <div id="sidebar-left">
        <div class="social arxiv">
            <a href="https://arxiv.org/abs/2305.02143" target="_blank">
                <p>Read on arXiv <i class="bi bi-newspaper"></i></p>
            </a>
        </div>
        <div class="social github">
            <a href="https://github.com/hcmlab/GANonymization" target="_blank">
                <p>Like on GitHub <i class="bi bi-github"></i></p>
            </a>
        </div>
    </div>
    <!-- Sidebar-Right -->
    <div id="sidebar-right" class="dropdown">
        <button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown"
                aria-expanded="false">
            <i class="bi bi-camera"></i>
        </button>
        <div id="dropdown-menu" class="dropdown-menu">
        </div>
    </div>
    <!-- Content -->
    <h1>GANonymization</h1>
    <video id="webcam" autoplay playsinline width="1920" height="1080" class="d-none"></video>
    <canvas id="canvas-landmarks" style="z-index: -10;"></canvas>
    <canvas id="canvas-anonymized" style="z-index: -11;"></canvas>
    <div class="custom-checkbox">
        <input id="status"
               type="checkbox"
               name="status">
        <label for="status">
            <div class="status-switch"
                 data-unchecked="Landmarks"
                 data-checked="Anonymized">
            </div>
        </label>
    </div>
</main>
</body>
</html>